---
interface Props {
    title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="Astro description" />
        <meta name="viewport" content="width=device-width" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="generator" content={Astro.generator} />
        <title>{title}</title>
    </head>
    <body class="overflow-hidden bg-black">
        <div id="three-container" class="h-screen w-screen"></div>
        <slot />
    </body>
    <style is:global></style>
    <script>
        import * as THREE from "three";
        import {
            type Font,
            FontLoader,
            TextGeometry,
        } from "three/examples/jsm/Addons.js";

        document.addEventListener("DOMContentLoaded", async () => {
            const fontLoader = new FontLoader();
            const lunasimaRegular = await new Promise<Font>((resolve) => {
                fontLoader.load("fonts/lunasima_regular.json", (font) => {
                    resolve(font);
                });
            });

            let radius = 0;
            let targetRotationZ = 0;
            let currentRotationZ = 0;
            let currentItem = 0;

            const itemGroup = new THREE.Group();
            const items = [
                {
                    name: "whoami",
                    body: itemTextMesh("whoami"),
                },
                {
                    name: "about",
                    body: itemTextMesh("about me"),
                },
                {
                    name: "projects",
                    body: itemTextMesh("projects"),
                },
                {
                    name: "resume",
                    body: itemTextMesh("resume"),
                },
                {
                    name: "blog",
                    body: itemTextMesh("  blog"),
                },
                {
                    name: "dogs",
                    body: itemTextMesh("  dogs"),
                },
            ];

            const renderer = new THREE.WebGLRenderer();
            let { camera, scene } = init();

            function render() {
                requestAnimationFrame(render);

                const diff = (targetRotationZ - currentRotationZ) * 0.04;
                currentRotationZ += diff;
                itemGroup.rotation.z = currentRotationZ;
                items.forEach((i) => {
                    i.body.lookAt(camera.position);
                    i.body.rotateX(0.5);
                    i.body.rotateZ(-0.05);
                });

                renderer.render(scene, camera);
            }
            render();

            let isScrolling = false;

            const pointer = {
                moving: false,
                x: 0,
                y: 0,
            };

            window.addEventListener("wheel", (e) => {
                if (isScrolling) {
                    return;
                }
                isScrolling = true;
                changeItem(Math.sign(e.deltaY));
                setTimeout(() => (isScrolling = false), 250);
            });

            window.addEventListener("keydown", (e) => {
                switch (e.key) {
                    case "l":
                    case "d":
                    case "ArrowRight":
                        changeItem(1);
                        break;
                    case "h":
                    case "a":
                    case "ArrowLeft":
                        changeItem(-1);
                        break;
                    default:
                        break;
                }
            });
            window.addEventListener("resize", () => {
                const world = init();
                camera = world.camera;
                scene = world.scene;
            });
            window.addEventListener("pointerdown", (e) => {
                pointer.moving = true;
                pointer.x = e.clientX;
                pointer.y = e.clientY;
            });
            window.addEventListener("pointermove", (e) => {
                if (!pointer.moving || isScrolling) {
                    return;
                }
                isScrolling = true;
                const dx = e.clientX - pointer.x;
                if (Math.abs(dx) > 3.5) {
                    changeItem(-Math.sign(dx));
                    isScrolling = true;
                }
            });
            window.addEventListener("pointerup", () => {
                pointer.moving = false;
                isScrolling = false;
            });
            window.addEventListener("pointerleave", () => {
                pointer.moving = false;
                isScrolling = false;
            });

            function init() {
                const container =
                    document.querySelector<HTMLElement>("#three-container")!;
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(
                    75,
                    container.clientWidth / container.clientHeight,
                    0.1,
                    1000,
                );
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.domElement.style.overflow = "hidden";
                container.replaceChildren(renderer.domElement);

                currentItem = 0;
                targetRotationZ = 0;
                currentRotationZ = 0;

                const page = window.location.pathname.replace("/", "");
                radius = container.clientWidth / 150;
                itemGroup.children = [];
                for (let i = 0; i < items.length; i++) {
                    const angle =
                        (2 * Math.PI * i) / items.length -
                        (3 * Math.PI) / items.length;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    items[i].body.position.set(x, y, 0);
                    items[i].body.scale.setScalar(0.003);
                    itemGroup.add(items[i].body);
                }

                const diff = container.clientWidth / container.clientHeight;
                itemGroup.position.y =
                    -(container.clientHeight - container.clientWidth) / 150 - 4;
                itemGroup.position.x = -0.5;
                itemGroup.rotation.x = -Math.PI / 2.5;

                scene.add(itemGroup);

                if (page !== "") {
                    const itemIndex = items.findIndex((i) => i.name === page);
                    changeItem(1, itemIndex);
                }

                container.replaceChildren(renderer.domElement);

                camera.position.z = 15;

                return { camera, scene };
            }

            function changeItem(dir: number, amount = 1) {
                dir = Math.sign(dir);
                currentItem =
                    (currentItem + dir * Math.abs(amount)) % items.length;
                if (currentItem < 0) {
                    currentItem += items.length;
                }
                targetRotationZ +=
                    (amount * (-dir * 2 * Math.PI)) / items.length;
                history.pushState({}, "", `/${items[currentItem].name}`);
            }

            function itemTextMesh(
                text: string,
                color: number = 0xffffff,
                font: Font = lunasimaRegular,
            ) {
                return new THREE.Mesh(
                    new TextGeometry(text, {
                        font,
                        size: 80,
                        height: 5,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 2,
                        bevelSize: 2,
                    }),
                    new THREE.MeshBasicMaterial({
                        color,
                    }),
                );
            }
        });
    </script>
</html>
